use crate::abi_impl::*;
use crate::env::{assembly_script_abort, get_remaining_points_for_instance, Env};
use crate::settings;
use crate::types::{Interface, Response};
use anyhow::{bail, Result};
use as_ffi_bindings::{Read as ASRead, StringPtr, Write as ASWrite};
use std::sync::Arc;
use wasmer::wasmparser::Operator;
use wasmer::{
    imports, CompilerConfig, Cranelift, Function, ImportObject, Instance, Module, Store, Universal,
    Val,
};
use wasmer_middlewares::Metering;

/// Create an instance of VM from a module with a given interface, an operation
/// number limit and a webassembly module
fn create_instance(limit: u64, module: &[u8], interface: &dyn Interface) -> Result<Instance> {
    let metering = Arc::new(Metering::new(limit, |_: &Operator| -> u64 { 1 }));
    let mut compiler_config = Cranelift::default();
    compiler_config.push_middleware(metering);
    let store = Store::new(&Universal::new(compiler_config).engine());
    let env = Env::new(interface);
    let resolver: ImportObject = imports! {
        "env" => {
            // Needed by wasm generated by AssemblyScript.
            "abort" =>  Function::new_native_with_env(&store, env.clone(), assembly_script_abort),
        },
        "massa" => {
            "assembly_script_print" => Function::new_native_with_env(&store, env.clone(), assembly_script_print),
            "assembly_script_call" => Function::new_native_with_env(&store, env.clone(), assembly_script_call_module),
            "get_remaining_points" => Function::new_native_with_env(&store, env, get_remaining_points),
        },
    };
    let module = Module::new(&store, &module)?;
    Ok(Instance::new(&module, &resolver)?)
}

pub(crate) fn exec(
    limit: u64,
    instance: Option<Instance>,
    module: &[u8],
    function: &str,
    param: &str,
    interface: &dyn Interface,
) -> Result<Response> {
    let instance = match instance {
        Some(instance) => instance,
        None => create_instance(limit, module, interface)?,
    };
    let mut env = as_ffi_bindings::Env::default();
    env.init(&instance)?;
    let param_ptr = *StringPtr::alloc(&param.to_string(), &env)?;
    match instance
        .exports
        .get_function(function)?
        .call(&[Val::I32(param_ptr.offset() as i32)])
    {
        Ok(value) => {
            // TODO: clean and define wat should be return by the main
            if function.eq(crate::settings::MAIN) {
                return Ok(Response {
                    ret: "0".to_string(),
                    remaining_points: get_remaining_points_for_instance(&instance),
                });
            }
            let str_ptr = StringPtr::new(value.get(0).unwrap().i32().unwrap() as u32);
            let memory = instance.exports.get_memory("memory")?;
            Ok(Response {
                ret: str_ptr.read(memory)?,
                remaining_points: get_remaining_points_for_instance(&instance),
            })
        }
        Err(error) => bail!(error),
    }
}

pub fn run(module: &[u8], limit: u64, interface: &dyn Interface) -> Result<u64> {
    let instance = create_instance(limit, module, interface)?;
    if instance.exports.contains(settings::MAIN) {
        Ok(exec(limit, Some(instance), module, settings::MAIN, "", interface)?.remaining_points)
    } else {
        Ok(limit)
    }
}
